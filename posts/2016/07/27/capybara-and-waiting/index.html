<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <!-- Always force latest IE rendering engine or request Chrome Frame -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    <!-- Use title if it's in the page YAML frontmatter -->
    <title>BHM</title>

    <!-- Bootstrap Stuff -->
    <link href=rel="stylesheet" type="text/css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="/stylesheets/normalize.css" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/blog.css" rel="stylesheet" type="text/css" />
    <script src="/javascripts/all.js" type="text/javascript"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51305292-1', 'auto');
  ga('send', 'pageview');

</script>

  </head>
  <body class="posts posts_2016 posts_2016_07 posts_2016_07_27 posts_2016_07_27_capybara-and-waiting posts_2016_07_27_capybara-and-waiting_index">
    <nav class="navbar navbar-default">
  <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapsible-content" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-links navbar-links--name pull-left">
      </a>
  </div>

  <div class="collapse navbar-collapse" id="navbar-collapsible-content">
    <a href="/posts" class="navbar-links pull-right">
      Posts
    </a>
    <a href="/projects" class="navbar-links pull-right">
      Projects
    </a>
    <a href="https://sg.linkedin.com/in/boahoman" class="navbar-links pull-right" target="_blank">
      LinkedIn
    </a>
  </div>
</nav>

    <div class="wrapper">
      <div class="container">
          <div class="article row">
    <h1 class="page-header article__article-title">
      Capybara & Waiting<br>
      <span>Published on Jul 27, 2016</span>
    </h1>
    <p>All of us do TDD or at least some form of automated testing, I hope! If you’re writing tests in Rails, 
you’re likely to be doing feature tests with <a href="https://github.com/jnicklas/capybara">Capybara</a> as well.</p>

<h3>Common Scenario</h3>

<p>Let’s look at a common scenario in a feature test: </p>

<ul>
<li>Load some form</li>
<li>Click a random button</li>
<li>Check if the refreshed page (or partially re-rendered pages) matches your expected results</li>
</ul>

<p>If you’re just transitioning from unit tests, it might be tempting to jump right to this option:</p>
<pre class="highlight ruby"><code><span class="n">visit</span> <span class="n">some_path</span>
<span class="n">click_button</span> <span class="s1">'Submit'</span> <span class="c1"># Does an AJAX request</span>

<span class="c1"># -- Page refresh or re-render --</span>

<span class="n">expect</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="s1">'#dom-id'</span><span class="p">).</span><span class="nf">text</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="s1">'something'</span>
</code></pre>

<p>You&rsquo;ll find that it doesn&rsquo;t work too well (not at all actually). This is because there is a delay 
between the button click and the actual completion of the code that is run as a result of that click. </p>

<p>It is not synchronous. It could be a page refresh, a partial render or a simple AJAX call. 
Its hard to predict how long exactly that is going to take.</p>

<h3>Built-in Matchers</h3>

<p>For this reason, Capybara provides us with some built-in matchers. They work amazingly well 
for these scenarios where you are waiting for something to finish before checking the content for text, 
DOM elements for visibility etc. Since the start, it was designed to automatically wait for elements 
to appear or disappear on the page.</p>
<pre class="highlight ruby"><code><span class="n">find</span><span class="p">(</span><span class="s1">'#dom-id'</span><span class="p">).</span><span class="nf">should</span> <span class="n">have_content</span> <span class="s1">'something'</span>
<span class="c1"># have_css, have_selector</span>
</code></pre>

<p>You can even define if the element should be visible or not after it is rendered. </p>
<pre class="highlight ruby"><code><span class="n">find</span><span class="p">(</span><span class="s1">'#dom-id'</span><span class="p">).</span><span class="nf">should</span> <span class="n">have_content</span> <span class="s1">'something'</span><span class="p">,</span> <span class="ss">visible: </span><span class="kp">false</span>
</code></pre>

<p>Magical. Right? </p>

<h3>The Story of <code>wait_until</code></h3>

<p>Despite the fact that the Capybara matchers were there from the start, pre-2.0, many people used <code>wait_until { ... }</code>. 
It was not intended. So in 2.0, it was deprecated altogether. At the same time, <code>wait_for_ajax</code> 
was introduced.  So why do we still need that if we have something like <code>have_content</code>? </p>

<p>Take a look at the scenario below, is <code>have_content</code> sufficient? What do you think?</p>
<pre class="highlight ruby"><code><span class="n">fill_in</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">with: </span><span class="s1">'Daniel'</span>
<span class="n">click_button</span> <span class="s1">'Link'</span> <span class="c1">#some AJAX call happens</span>
<span class="n">reload_page</span>
<span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_content</span> <span class="s1">'Linked'</span>
</code></pre>

<p>It depends. There&rsquo;s a chance that the <code>reload_page</code> would happen before the AJAX code finishes. 
And the tests would randomly fail. That&rsquo;s not good; we all want deterministic results for our tests, right?</p>

<h3>Enter <code>wait_for_ajax</code></h3>

<p><code>wait_for_ajax</code> was designed to be used whenever you need to make sure that all AJAX calls have completed 
before proceeding, or in this case, before the page reload.</p>

<p>Alternatively, you could also use <code>have_selector</code> to block the execution. But in my opinion, 
if you don&rsquo;t actually want to test the content, using <code>wait_for_ajax</code> makes a lot more sense. </p>

<p>So the next time you encounter similar issues, check to make sure that you are using the Capybara built-in matchers!</p>

<p>What do you think? Are your experiences similar?</p>

  </div>

      </div>
    </div>
  </body>
</html>
